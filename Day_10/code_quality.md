## code quality- 5pillars
1. Readability -75%
2. meaningful variables
3. Difference between declarative and imperative
4. Imperative
Declarative -what to do and imperative -how to do
arr.map(n=>n*2)---what to do  -->dot chaining
map is more easier to read --code readability will be increasing 
declarative way of coding
will improve the readability  with reusability of the code - encompass with 
## code debt - a set of code will not be tested -- low quality code  to customer needs
### Maintainablity-code debt,Reuse
### refactoring the code to reduce the code debt  and make code as better
### output is same but the quality is increased
###code quality - 5pillars 
1.Readability-75 % declarative ,comments
2.Maintainability- code Debt decrease ,Reuse, tomorrow never comes 
3.Extensibility -camera eg DSLR CAMERA Changing the  lens --features existing to be integrated in  project eg road in all scenarios
4.Modularity 
5.Testability--attributes need for the basic testcases in testing team side testcases worthy of writing the code with code quality and end to end test cases 
cypress used in javascript  automation 
end to end cases and unit test cases as well as software development in testing
6.Performance
0(n)- time complexity
n -n times --order of n 
number of elements in the array
number of loops -O(n)
how much times is related to o(n)
i =0,j=0 output=1 for i =0(  4times for i =0) for 16 times  n=4 n square this is time complexity ,arr[i]
o(n cube)===>o(n) so it will be performance will be better
y=x square is parabola the graphical representation  in according to n ,so the curve should be long and it should be worst in terms of the n
upwards is dangerous and nested loops should be avoided-- need for n complexities  in each cases applicable
O(2n)=O(n) --line increases linearly as not as fast as parabola bringing O(n square ) to O(n) is fine .
space complexity 
fold as used in reduce
reduce your  logic which  is implemented in all the scenarios
general logic + next value is equal to tile and its design is implemented in all sides
accumulate value  will be returned to the current value last value will be returned atlast 
initial value and function takes the  arguments in case of anonymous  for both accumulator and current values
the first value will be stored in accumulator and second value  will be stored in current 
reduce can return any data type
